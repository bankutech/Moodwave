<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>DJ MoodWave Night</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
* { margin:0; padding:0; box-sizing:border-box; font-family:"Segoe UI",sans-serif; }

body {
  height:100vh;
  overflow:hidden;
  display:flex;
  justify-content:center;
  align-items:center;
  color:#fff;

  /* Original blue background kept, middle overlay for night mood */
  background:
    radial-gradient(circle at center, rgba(79,70,229,0.25) 0%, rgba(55,48,163,0) 40%), /* soft purple overlay */
    radial-gradient(circle at top, #0ea5e9 0%, transparent 35%), /* blue top */
    radial-gradient(circle at bottom, #020617, #000814); /* blue bottom */
}

/* Floating blue glow circles */
body::before, body::after {
  content:"";
  position:absolute;
  width:700px;
  height:700px;
  border-radius:50%;
  background: radial-gradient(circle, rgba(14,165,233,0.35), transparent 60%);
  filter: blur(120px);
  animation: move 10s infinite alternate;
}
body::after { animation-delay: 3s; }

@keyframes move {
  from { transform: translate(-150px,-150px);}
  to { transform: translate(150px,150px);}
}

/* Player container */
.player {
  width:100%;
  height:100%;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  z-index:2;
}

/* Title */
h1 {
  font-size:2.5rem;
  letter-spacing:4px;
  margin-bottom:35px;
  text-shadow: 0 0 20px #4f46e5, 0 0 40px #3730a3; /* soft purple glow */
  color:#fff;
}

/* Visualizer bars */
.visualizer {
  display:flex;
  align-items:flex-end;
  gap:10px;
  height:240px;
}

.bar {
  width:12px;
  height:30px;
  border-radius:20px;
  background: linear-gradient(180deg, #7c3aed, #4f46e5, #3730a3); /* purple ‚Üí deep blue */
  box-shadow: 0 0 15px #7c3aed, 0 0 35px #4f46e5;
  transition: height 0.07s ease;
}

/* Play Button */
button {
  margin-top:45px;
  padding:16px 50px;
  font-size:18px;
  letter-spacing:2px;
  border:none;
  border-radius:50px;
  background: linear-gradient(90deg, #7c3aed, #4f46e5);
  color:#fff;
  cursor:pointer;
  box-shadow:0 0 25px #7c3aed,0 0 50px #4f46e5;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

button:hover { transform: scale(1.1); }

.controls { display:flex; align-items:center; gap:20px; margin-top:30px; }
.control-btn { padding:12px 20px; font-size:16px; margin-top:0; }
.shuffle-btn { padding:12px 20px; font-size:16px; margin-top:0; }
.shuffle-btn.active { background: linear-gradient(90deg, #4f46e5, #7c3aed); box-shadow:0 0 30px #7c3aed,0 0 60px #4f46e5; }

/* Back Button */
.back-btn {
  position: fixed;
  top:25px;
  left:25px;
  padding:10px 22px;
  font-size:16px;
  border:none;
  border-radius:30px;
  background: linear-gradient(90deg, #7c3aed, #4f46e5);
  color:#fff;
  cursor:pointer;
  box-shadow:0 0 15px #7c3aed,0 0 35px #4f46e5;
  z-index:999;
}

.back-btn:hover {
  transform: scale(1.1);
  box-shadow:0 0 25px #7c3aed,0 0 60px #4f46e5;
}

audio{display:none;}
</style>
</head>

<body>

<!-- Back button -->
<button class="back-btn" onclick="window.location.href='mood.html'">‚üµ Back</button>

<div class="player">
<h1>Night MoodVibes</h1>
<div class="visualizer" id="visualizer"></div>
<div class="controls">
  <button class="control-btn" id="prevBtn">‚èÆ PREV</button>
  <button id="playBtn">‚ñ∂ PLAY</button>
  <button class="control-btn" id="nextBtn">NEXT ‚è≠</button>
</div>
<button class="shuffle-btn" id="shuffleBtn">üîÄ SHUFFLE</button>
<audio id="audio" controls></audio>
</div>

<script>
const audio=document.getElementById("audio");
const playBtn=document.getElementById("playBtn");
const visualizer=document.getElementById("visualizer");
const barsCount=52;
const bars=[];

// Create bars
for(let i=0;i<barsCount;i++){
  const bar=document.createElement("div");
  bar.className="bar";
  bar.style.height="30px"; // Initial height so bars are visible
  visualizer.appendChild(bar);
  bars.push(bar);
}

let audioContext,analyser,dataArray;
let currentSongIndex=0;
let songs=[];
let isShuffle=false;
let shuffleOrder=[];

// Fetch Night songs - try backend API first, fallback to JSON file for GitHub Pages
function loadSongs(){
  fetch('/songs?mood=Night')
  .then(res=>{
    if(!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
    return res.json();
  })
  .then(data=>{
    songs=data;
    processSongs();
  })
  .catch(err=>{
    console.log("Backend not available, using JSON file:", err);
    loadFromJSON();
  });
}

function loadFromJSON(){
  fetch('songs.json')
  .then(res=>res.json())
  .then(allSongs=>{
    // Filter by mood
    songs = allSongs.filter(song => song.mood === 'Night');
    // Convert relative paths to absolute if needed
    songs = songs.map(song => {
      if(song.audio_url && !song.audio_url.startsWith('http')){
        // Ensure path is relative to current location
        song.audio_url = song.audio_url;
      }
      return song;
    });
    processSongs();
  })
  .catch(err=>{
    console.error("Error loading songs.json:", err);
    playBtn.textContent='‚ùå Error loading songs';
  });
}

function processSongs(){
  console.log('Loaded songs:', songs);
  if(songs.length>0) {
    initializeShuffle();
    loadSong(0);
    playBtn.textContent='‚ñ∂ PLAY';
  } else {
    playBtn.textContent='‚ùå No songs found';
  }
}

// Start loading songs
loadSongs();

function initializeShuffle(){shuffleOrder=Array.from({length:songs.length},(_,i)=>i);}
function shuffleArray(array){const shuffled=[...array];for(let i=shuffled.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[shuffled[i],shuffled[j]]=[shuffled[j],shuffled[i]];}return shuffled;}
function loadSong(index){
  if(index<0||index>=songs.length)return;
  currentSongIndex=index;
  const wasPlaying=!audio.paused;
  
  // Stop current playback
  audio.pause();
  audio.currentTime = 0;
  
  // Set new source
  const newSrc = songs[currentSongIndex].audio_url;
  console.log('Loading song:', songs[currentSongIndex].title, 'URL:', newSrc);
  audio.src = newSrc;
  audio.load();
  
  // Wait for audio to be ready before playing
  const playWhenReady = function(){
    if(wasPlaying && audio.readyState >= 2){ // HAVE_CURRENT_DATA
      audio.play().catch(err=>{
        console.error('Error playing song after load:', err);
        // Try to resume AudioContext if needed
        if(audioContext && audioContext.state === 'suspended'){
          audioContext.resume().then(()=>{
            audio.play().catch(e=>console.error('Error after resume:', e));
          });
        }
      });
    }
    audio.removeEventListener('canplaythrough', playWhenReady);
    audio.removeEventListener('loadeddata', playWhenReady);
  };
  
  audio.addEventListener('canplaythrough', playWhenReady, {once: true});
  audio.addEventListener('loadeddata', playWhenReady, {once: true});
  
  // Fallback: if audio loads quickly, try playing immediately
  if(audio.readyState >= 2 && wasPlaying){
    setTimeout(()=>{
      if(audio.paused && wasPlaying){
        audio.play().catch(err=>console.error('Error playing (fallback):', err));
      }
    }, 100);
  }
}
function getNextIndex(){if(isShuffle){const currentPos=shuffleOrder.indexOf(currentSongIndex);const nextPos=(currentPos+1)%shuffleOrder.length;return shuffleOrder[nextPos];}else{return(currentSongIndex+1)%songs.length;}}
function getPrevIndex(){if(isShuffle){const currentPos=shuffleOrder.indexOf(currentSongIndex);const prevPos=(currentPos-1+shuffleOrder.length)%shuffleOrder.length;return shuffleOrder[prevPos];}else{return(currentSongIndex-1+songs.length)%songs.length;}}

audio.addEventListener('error', (e)=>{
  console.error('Audio error:', e);
  console.error('Audio src:', audio.src);
  console.error('Audio error details:', audio.error);
  playBtn.textContent='‚ùå Error loading audio';
  if(audio.error){
    alert('Audio error: ' + audio.error.message + '\nURL: ' + audio.src);
  }
});

audio.addEventListener('canplay', ()=>{
  console.log('Audio ready to play');
});

// Play button
playBtn.addEventListener("click", async ()=>{
  if(songs.length===0){
    alert('No songs available. Please wait for songs to load.');
    return;
  }
  
  // Ensure audio source is loaded
  if(!audio.src || audio.src === ''){
    loadSong(0);
  }
  
  if(!audioContext){
    audioContext=new AudioContext();
    // Resume AudioContext if suspended (browser autoplay policy)
    if(audioContext.state === 'suspended'){
      await audioContext.resume();
    }
    const source=audioContext.createMediaElementSource(audio);
    analyser=audioContext.createAnalyser();
    analyser.fftSize=128;
    dataArray=new Uint8Array(analyser.frequencyBinCount);
    source.connect(analyser);
    analyser.connect(audioContext.destination);
  } else if(audioContext.state === 'suspended'){
    await audioContext.resume();
  }
  
  if(audio.paused){
    try{
      await audio.play();
      playBtn.textContent='‚è∏ PAUSE';
    }catch(err){
      console.error('Play error:', err);
      alert('Error playing audio: ' + err.message);
    }
  }else{
    audio.pause();
    playBtn.textContent='‚ñ∂ PLAY';
  }
});

// Animate bars - runs continuously
let isAnimating = false;
function animate(){
  requestAnimationFrame(animate);
  
  if(!analyser || !dataArray){
    // Show default wave animation when no audio is playing
    bars.forEach((bar,i)=>{
      const baseHeight = 30;
      const wave = Math.sin(Date.now() / 200 + i * 0.1) * 10;
      bar.style.height = (baseHeight + wave) + "px";
    });
    return;
  }
  
  // Use audio data when available
  analyser.getByteFrequencyData(dataArray);
  bars.forEach((bar,i)=>{
    const value=dataArray[i]||0;
    bar.style.height=Math.max(25,value*1.3)+"px"; // calm height
  });
}

// Start animation loop immediately so bars are always visible
animate();

document.getElementById("nextBtn").addEventListener("click",()=>{if(songs.length===0)return;const nextIndex=getNextIndex();loadSong(nextIndex);if(!audio.paused){audio.play().catch(err=>console.error('Error playing next song:',err));}});
document.getElementById("prevBtn").addEventListener("click",()=>{if(songs.length===0)return;const prevIndex=getPrevIndex();loadSong(prevIndex);if(!audio.paused){audio.play().catch(err=>console.error('Error playing previous song:',err));}});
document.getElementById("shuffleBtn").addEventListener("click",()=>{isShuffle=!isShuffle;const shuffleBtn=document.getElementById("shuffleBtn");if(isShuffle){shuffleOrder=shuffleArray(Array.from({length:songs.length},(_,i)=>i));const currentPos=shuffleOrder.indexOf(currentSongIndex);if(currentPos>0){[shuffleOrder[0],shuffleOrder[currentPos]]=[shuffleOrder[currentPos],shuffleOrder[0]];}shuffleBtn.classList.add("active");shuffleBtn.textContent="üîÄ SHUFFLE ON";}else{shuffleBtn.classList.remove("active");shuffleBtn.textContent="üîÄ SHUFFLE";}});
audio.addEventListener("ended",()=>{
  if(songs.length===0)return;
  const nextIndex=getNextIndex();
  loadSong(nextIndex);
  // Auto-play next song after it loads
  audio.addEventListener('canplaythrough', function autoPlayNext(){
    audio.play().catch(err=>console.error('Error playing next song:',err));
    audio.removeEventListener('canplaythrough', autoPlayNext);
  }, {once: true});
});
</script>

</body>
</html>
